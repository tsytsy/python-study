一个完整的消息可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送。
粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

粘包问题是由 TCP 是面向字节流协议因此没有消息边界所引起的。而 UDP 是面向数据报的协议，所以不存在拆包粘包问题。
存在以下特殊情况：

1. 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就 ok，不用考虑粘包；
2. 如果利用 TCP 短连接时，不会出现粘包问题；
3. 当发送数据存在一定结构，并且需要维护长连接时，则需要考虑粘包问题；

问题原因
出现拆包粘包现象的原因既可能由发送方造成，也可能由接收方造成:

1. 要发送的数据大于TCP发送缓冲区剩余空间大小，发生拆包；
2. 待发送数据大于MSS（最大报文长度），TCP在传输前进行拆包；
3. 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，造成粘包;
4. 接收方没能及时地接收缓冲区的数据，造成粘包;


解决方法
解决粘包的方法，是由应用层进行分包处理，本质上就是由应用层来维护消息和消息的边界（即定义自己的会话层和表示层协议）
定义包结构；一般可以定义为 包头+包体；包头一般定长，并且至少包含了文件大小字段；包体就是发送文件的二进制数据；
接收端一定是先收到包头，解析包头中的文件大小字段后，继续接收文件大小规定的包数据，读不够继续等待，如果超长，
说明读到了下一个文件或数据包的内容， 应该缓存起来，给下个包使用。等到读取到了指定大小的包后，数据就已经是完整的。
也有人采用特殊包尾的方式来作为粘包切割的依据，但这种方法不太精确，如果发送内容中包含特殊包尾就会出错。
。

1、TCP
打个比方比喻TCP，你家里有个蓄水池，你可以里面倒水，蓄水池上有个龙头，你可以通过龙头将水池里的水放出来，然后用各种各样
的容器装（杯子、矿泉水瓶、锅碗瓢盆）接水。 上面的例子中，往水池里倒几次水和接几次水是没有必然联系的，也就是说你可以只
倒一次水，然后分10次接完。另外，水池里的水接多少就会少多少；往里面倒多少水，就会增加多少水，但是不能超过水池的容量，
多出的水会溢出。
结合TCP的概念，水池就好比接收缓存，倒水就相当于发送数据，接水就相当于读取数据。好比你通过TCP连接给另一端发送数据，
你只调用了一次write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，
但是对方可以一次就收完。（假设数据都能到达）但是，你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发
送过量数据，则对方的缓存满了就会把多出的数据丢弃。 这种情况是设置非阻塞I/O模型，会把内存耗尽，因为socket是存在内核
中的。
2、UDP
UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UPD是基于报文的，在接收的时候，
每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。也就说，
如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。
3、为什么
其实，这种不同是由TCP和UDP的特性决定的。TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由
同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。
而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候
，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文
的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。


udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y>x数据就丢失，
这意味着udp根本不会粘包，但是会丢数据，不可靠